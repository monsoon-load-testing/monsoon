Order of difficulty:
  - S3
  - startingLambda
  - ecs

S3:
  - create a bucket
  - extract the name
  - grant read/write permissions to startingLambda

startingLambda:
  - eventBridge:
    - dynamically plug in the end user's AWS account number into the ARN of the EventBridge target 
      (ARN for Metronome Lambda)
  - config:
    - covered on S3
  - ecs:
    - receive the vpc-id from custom vpc and plug in

ECS:
  - create a custom vpc
  - extract vpc-id
  - extract user's IAM credentials and plug in
  - calculate how many concurrent users from CLI and determine how many tasks and plug in
  - create an ecsTaskExecutionRole for the taskDefinition -> pass the name of the policy to startingLambda

General solution:
  - pass everything to environment variables in the startingLambda
  - expose property to construct
  - pass through props
  - add extra properties on instances in the construct (ex: this.bucket) to solve circular dependencies
  - use available cdk methods (for example: grantReadWrite)


import * as cdk from "@aws-cdk/core";
import { MyLambda } from "./my_lambda";
import { MyBucket } from "./my_s3";

export class LambdaTutorialStack extends cdk.Stack {
  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

const myBucket = new MyBucket(this, "rdh-test");
    const myLambda = new MyLambda(this, "rdh-MyLambda", {
      bucketName: myBucket.bucket.bucketName,
    });
    myBucket.bucket.grantReadWrite(myLambda.handler);
  }
}

import * as cdk from "@aws-cdk/core";
import * as lambda from "@aws-cdk/aws-lambda";
import * as s3 from "@aws-cdk/aws-s3";

export class MyBucket extends cdk.Construct {
  scope: cdk.Construct;
  id: string;
  props: any;
  bucket: s3.Bucket;
  constructor(scope: any, id: any, props?: any) {
    super(scope, id);

    this.bucket = new s3.Bucket(this, id);
  }
}
